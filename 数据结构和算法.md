数据结构之排序

排序的基本概念：

	排序就是将一个元素的任意序列重排成一个按关键字有序的序列。为了查找方便，通常要求计算机中的表是按关键字有序的。当待排序元素的关键字均不相同时，排序结果是唯一的，否则排序结果可能不唯一。如果待排序表中有两个元素R_i和R_j，其对应的关键字K_i=K_j，且在排序前R_i在R_j前面，如果使用某一排序算法排序后，R_i仍在Rj的前面，则称这个排序算法是稳定的，否则称排序算法是不稳定的。

	根据排序过程数据是否完全在内存中分为两类：内部排序和外部排序。内部排序是指在排序期间，元素全部存放在内存中的排序；外部排序是指在排序期间元素无法全部同时存放在内存中，必须在排序的过程中根据要求不断地在内、外存之间移动的排序。

	通常，在排序过程中要进行两种操作：比较和移动。通过比较两个关键字，确定对应元素的关系，然后通过移动元素以达到有序。比较操作对于各种算法都是必须的。移动操作则分为三种情况：1.若记录采用顺序存储结构，则实现排序必须借助移动记录；2.若记录采用静态链表存储结构，则不需移动记录，仅需要修改游标即可；3.若记录采用链式存储结构，则只需调整指向记录的指针。

	内部排序算法的性能由时间复杂度和空间复杂度确定。时间复杂度一般由比较次数和移动次数来衡量，此外还需要考虑记录的初始排列和记录个数。



插入排序

	基本思想：每一趟将一个待排序的记录，按其关键字的大小插入到前面已经排好序的子序列中的合适位置上，直到全部记录插入完成。

直接插入排序

	基本思想：将一个记录插入到已排序好的有序表中，从而得到一个新，记录数增1的有序表。即：先将序列的第1个记录看成是一个有序的子序列，然后从第2个记录逐个进行插入，直至整个序列有序为止。要点：设立哨兵，作为临时存储和判断数组边界之用。

直接插入排序算法（升序）的Java实现如下：

    import java.util.*;
       class DirectInsertSort {
           public static void main(String args[]) {
              Scanner sc = new Scanner(System.in);
               while(sc.hasNext()){
                   int n = sc.nextInt();//要排序的元素的个数
                   int[] A = new int[n];
                   for (int i = 0;i < n;i++) {
                       A[i] = sc.nextInt();
                  }
                directInsertSort(A,n);
              }
          }
     
          public static void directInsertSort(int[] A,int n){
              for (int i = 1;i < n ;i++) {//第0位独自作为有序数列，从第1位开始向后遍历
                  //0~i-1位为有序，若第i位小于i-1位，继续寻位并插入，
                  //否则认为0~i位也是有序的，忽略此次循环，相当于continue
                  if(A[i] < A[i-1]){
                      int temp = A[i];//保存第i位的值
                      int k = i-1;
                      for(int j = k;j >= 0 && temp < A[j];j--){
                          //从第i-1位向前遍历并移位，直至找到小于第i位值停止
                         A[j+1] = A[j];
                          k--;
                      }
                      A[k+1] = temp;//插入第i位的值
                  }
              }
      }

	空间复杂度：需要常数个辅助变量，空间复杂度为O(1)

	时间复杂度：在最好的情况下，即初始排序有序，则每次循环只需要与前一个记录比较1次，且不需要移动，总的比较次数为n-1，时间复杂度为O(n)；在最坏情况下，即初始排序为逆序，则每个记录都要与之前的子数组中的所有记录比较，总的比较次数最大，总的移动次数最大，时间复杂度为O(n^2)。

	直接插入排序的平均时间复杂度为O(n^2)，它既适用于顺序存储的线性表，也适用于链式存储的线性表，且直接插入排序是稳定的。

折半插入排序

	折半插入排序（binary insertion sort）是对插入排序算法的一种改进，由于排序算法过程中，就是不断的依次将元素插入前面已排好序的序列中。由于前半部分为已排好序的数列，这样我们不用按顺序依次寻找插入点，可以采用折半查找的方法来加快寻找插入点的速度。

	在将一个新元素插入已排好序的数组的过程中，寻找插入点时，将待插入区域的首元素设置为a[low]，末元素设置为a[high]，则轮比较时将待插入元素与a[m]，其中m=(low+high)/2相比较,如果比参考元素小，则选择a[low]到a[m-1]为新的插入区域(即high=m-1)，否则选择a[m+1]到a[high]为新的插入区域（即low=m+1），如此直至low<=high不成立，即将此位置之后所有元素后移一位，并将新元素插入a[high+1]。

	稳定性及复杂度：折半插入排序算法是一种稳定的排序算法，比直接插入算法明显减少了关键字之间比较的次数，因此速度比直接插入排序算法快，但记录移动的次数没有变，所以折半插入排序算法的时间复杂度仍然为O(n^2)，与直接插入排序算法相同。空间复杂度为O(1)

    import java.util.*;
    public class BinaryInsertSort{
    	public static void main(String[] args) {
    		Scanner sc = new Scanner(System.in);
    		while(sc.hasNext()){
    			int n = sc.nextInt();//数组的大小
    			int[] A = new int[n];
    			for (int i = 0;i < n;i++ ) {
    				A[i] = sc.nextInt();
    			}
    
    			binaryInsertSort(A,n);
    		}
    	}
    
    	public static void binaryInsertSort(int[] A,int n){
    		for (int i = 1;i < n; i++) {
    			int temp = A[i];
    			int low = 0;
    			int high = i - 1;
    			while(low <= high){
    				int mid = (high + low) / 2;//找到中间位置
    				if(temp < A[mid]){
    					//到小于mid的部分去找
    					high = mid - 1;
    				}else{
    					//到大于mid的部分去找
    					low = mid + 1;
    				}
    			}
    
    			for (int j = i;j > low; j--) {
    				A[j] = A[j-1];
    			}
    
    			A[low] = temp;
    		}
    
    		for (int i = 0;i < n;i++ ) {
    			System.out.print(A[i]);
    			if(i != n-1){
    				System.out.print(",");
    			}
    		}
    	}
    }

希尔排序

	基本思想：先取一个小于n的整数d1作为第一个增量，把文件的全部记录分组。所有距离为d1的倍数的记录放在同一个组中。先在各组内进行直接插入排序；然后，取第二个增量d2<d1重复上述的分组和排序，直至所取的增量  =1(  <  …<d2<d1)，即所有记录放在同一组中进行直接插入排序为止。

	复杂度及稳定性：希尔排序的空间复杂度为O(n)，平均时间复杂发为O(n^1.3)，它是一个不稳定的排序算法。

    import java.util.*;
    public class ShellSort{
    	public static void main(String[] args) {
    		Scanner sc = new Scanner(System.in);
    		while(sc.hasNext()){
    			int n = sc.nextInt();//数组的大小
    			int[] A = new int[n];
    			for (int i = 0;i < n;i++ ) {
    				A[i] = sc.nextInt();
    			}
    
    			shellSort(A,n);
    		}
    	}
    
    	public static void shellSort(int[] A,int n){
    		int step = n;//step步长
    		while(true){
    			for (int i = 0;i < step;i++ ) {//步长变化
    				for(int j = i;j + step < n;j += step){
    					int temp;
    					if(A[j] > A[j+step]){//对元素进行排序
    						temp = A[j];
    						A[j] = A[j+step];
    						A[j+step] = temp;
    					}
    			}
    		}
    		if(step == 1){//当步长为1时，排序完成，跳出循环
    			break;
    		}
    		step--;
    	}
    
    	for (int i = 0;i < n;i++ ) {
    		System.out.print(A[i]);
    		if(i != n-1){
    			System.out.print(",");
    		}
    	}
    	}
    }

交换排序

	所谓交换，就是根据序列中两个元素的关键字比较结果来交换这两个元素在序列中的位置。

冒泡排序

	冒泡排序（Bubble Sort）是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。

冒泡排序算法的步驟如下：

1. 比较相邻的元素。如果第一个比第二个大，就交换他们两个。
2. 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。
3. 针对所有的元素重复以上的步骤，除了最后一个。
4. 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。
   冒泡排序的算法的实现如下：

    import java.util.Scanner;
    
    /**
     * Created by Feng on 2017/3/13.
     * 冒泡排序
     */
    public class BubbleSort {
        public static void main(String[] args) {
            Scanner sc = new Scanner(System.in);
            while (sc.hasNext()) {
                int n = sc.nextInt();//数组大小
                int[] A = new int[n];
                for (int i = 0; i < n; i++) {
                    A[i] = sc.nextInt();
                }
    
                bubbleSort(A, n);
            }
        }
    
        private static void bubbleSort(int[] a, int n) {
            int temp = 0;
            for (int i = 0; i < n - 1; i++) {//最多进行n-1趟
                for (int j = 0; j < n - i - 1; j++) {
                    if (a[j] > a[j + 1]) {//将大的值放在后面
                        temp = a[j];
                        a[j] = a[j + 1];
                        a[j + 1] = temp;
                    }
                }
            }
    
            for (int i = 0; i < n; i++) {
                System.out.print(a[i]);
                if (i != n - 1) {
                    System.out.print(",");
                }
            }
        }
    }

	冒泡排序算法的稳定性及复杂度：若文件的初始状态是正序的，一趟扫描即可完成排序。所需的关键字比较次数和记录移动次数均达到最小值：比较次数为n-1，移动次数为0，所以冒泡排序最好的时间复杂度是O(n)。 若初始文件是反序的，需要进行n-1趟排序。每趟排序要进行n-i次关键字的比较(1≤i≤n-1)，且每次比较都必须移动记录三次来达到交换记录位置。在这种情况下，比较和移动次数均达到最大值，所以冒泡排序的最坏时间复杂度为O(n^2)。冒泡排序算法的平均时间复杂度为O(n^2)，空间复杂度为O(1)，冒泡排序是一种稳定的排序算法。

快速排序

	算法思想：基于分治的思想，是冒泡排序的改进型。首先在数组中选择一个基准点（该基准点的选取可能影响快速排序的效率，后面讲解选取的方法），然后分别从数组的两端扫描数组，设两个指示标志（lo指向起始位置，hi指向末尾)，首先从后半部分开始，如果发现有元素比该基准点的值小，就交换lo和hi位置的值，然后从前半部分开始扫秒，发现有元素大于基准点的值，就交换lo和hi位置的值，如此往复循环，直到lo>=hi,然后把基准点的值放到hi这个位置。一次排序就完成了。以后采用递归的方式分别对前半部分和后半部分排序，当前半部分和后半部分均有序时该数组就自然有序了。

快速排序算法代码实现如下：

    import java.util.Scanner;
    
    /**
     * Created by Feng on 2017/3/14.
     * 快速排序
     */
    public class QuickSort {
        public static void main(String[] args) {
            Scanner sc = new Scanner(System.in);
            while (sc.hasNext()) {
                int n = sc.nextInt();//数组大小
                int[] A = new int[n];
                for (int i = 0; i < n; i++) {
                    A[i] = sc.nextInt();
                }
    
                int low = 0;
                int high = A.length - 1;
                quickSort(A, low, high);
    
                for (int i = 0; i < n; i++) {
                    System.out.print(A[i]);
                    if (i != n - 1) {
                        System.out.print(",");
                    }
                }
            }
        }
    
        private static void quickSort(int[] a, int low, int high) {
            if (low > high) {
                return;
            }
    
            int index = partition(a, low, high);//划分操作，将表分为两个表
            quickSort(a, low, index - 1);//依次对两个表进行递归排序
            quickSort(a, index + 1, high);
        }
    
        private static int partition(int[] a, int low, int high) {
            //选取一个元素作为基准
            int key = a[low];
            while (low < high) {//循环条件
                while (a[high] >= key && high > low) {//从后半部分扫描
                    high--;
                }
                a[low] = a[high];//将比枢纽值小的元素移到左端
    
                while (a[low] <= key && low < high) {//从前半部分向后扫描
                    low++;
                }
                a[high] = a[low];//将比枢纽值大的元素移到右端
            }
    
            a[low] = key;//枢纽元素存放到最终位置
    
            return low;
        }
    }

	快速排序算法的复杂度及稳定性：快速排序的运行效率与划分是否对称有关，而后者又与具体的划分算法有关。快速排序的最坏情况发生在两个区域分别包含n-1个和0个元素时，这种最大程度的不对称若发生在每一层递归上，就得到时间复杂度为O(n^2)。在最理想情况下，也即Partition做到最平衡的划分，得到的两个子问题的大小都不可能大于n/2，在这种情况下时间复杂度为O(nlog_2n)。空间复杂度最好的情况下是O(log_2n)，最坏情况下是O(n)，快速排序是一种不稳定的排序算法。

选择排序

	选择排序的思想是，每一趟(如第i趟)在后面n-i+1(i=1,2,...,n-1)个待排序元素中选出关键字最小的元素，作为有序元素序列的第i个元素，共需要进行n-1趟。

简单选择排序

	基本思想：将最小的元素找出来并放在序列的最前面，在剩下的元素中继续找出最小元素放在第二个位置上，以此类推，每次选出一个元素，即可确定其在有序序列中的最终位置。

	简单排序算法的代码如下：

    /**
     * 简单选择排序
     * @author Administrator
     *
     */
    public class SelectMethod {
    
        /**
         * 简单选择排序
         * 原理：从i到args.length-1，每次迭代将i到args.length-1中最小（最大）的那个数交换到i的位置，然后i++，再循环
         * @param array 待排序的数组
         */
        public static void simpleSelectMethod(int[] array){
            //minLoc用于记录i+1到args.length-1这个区间的最小值的下标（i会递增），i表示要交换的位置。
            for (int i=0,j=0,minLoc=0; i<array.length; i++) {
                minLoc = i;
                for (j=i+1; j < array.length; j++) {//找出i+1到args.length-1这个区间的最小值的下标
                    if(array[j] < array[minLoc]){
                        minLoc = j;
                    }
                }
    
                if(minLoc!=i){//如果minLoc!=i，说明minLoc有变化，就进行交换
                    int temp = array[i];
                    array[i] = array[minLoc];
                    array[minLoc] = temp;
                }
            }
        }
    
        public static void main(String[] args) {
            int[] args1 = {12,53,48,26,43,62,46,48};
            simpleSelectMethod(args1);
            for (int i = 0; i < args1.length; i++) {
                System.out.println(args1[i]);
            }
        }
    }

 	简答选择排序的时空复杂度和稳定性：在简单选择排序过程中，所需移动记录的次数比较少。最好情况下，即待排序记录初始状态就已经是正序排列了，则不需要移动记录。最坏情况下，即待排序记录初始状态是按第一条记录最大，之后的记录从小到大顺序排列，则需要移动记录的次数最多为3(n-1)。简单选择排序过程中需要进行的比较次数与初始状态下待排序的记录序列的排列情况无关。当i=1时，需进行n-1次比较；当i=2时，需进行n-2次比较；依次类推，共需要进行的比较次数是(n-1)+(n-2)+…+2+1=n(n-1)/2，即进行比较操作的时间复杂度为O(n^2)，进行移动操作的时间复杂度为O(n)。空间复杂度为O(1)。简单选择排序是不稳定排序。

堆排序

	基本思想：堆排序是一种树形选择排序算法，在排序过程中，将L[1...n]看成是一棵完全二叉树的顺序存储结构，L[1]作为二叉树的根，其余元素L[2..n]依次逐层从左到右顺序排序，利用完全二叉树中双亲节点和孩子节点之间的内在关系，在当前无序区中选择关键字最大(或最小)的元素。堆是指n个关键字序列L[1...n]，堆又分为大根堆和小根堆：根结点（亦称为堆顶）的关键字是堆里所有结点关键字中最小者的堆称为小根堆，又称最小堆。根结点（亦称为堆顶）的关键字是堆里所有结点关键字中最大者，称为大根堆，又称最大堆。

	堆排序利用了大根堆（或小根堆）堆顶记录的关键字最大（或最小）这一特征，使得在当前无序区中选取最大（或最小）关键字的记录变得简单。

（1）用大根堆排序的基本思想

	① 先将初始文件R[1..n]建成一个大根堆，此堆为初始的无序区

	② 再将关键字最大的记录R[1]（即堆顶）和无序区的最后一个记录R[n]交换，由此得到新的无序区R[1..n-1]和有序区R[n]，且满足R[1..n-1].keys≤R[n].key

	③由于交换后新的根R[1]可能违反堆性质，故应将当前无序区R[1..n-1]调整为堆。然后再次将R[1..n-1]中关键字最大的记录R[1]和该区间的最后一个记录R[n-1]交换，由此得到新的无序区R[1..n-2]和有序区R[n-1..n]，且仍满足关系R[1..n-	2].keys≤R[n-1..n].keys，同样要将R[1..n-2]调整为堆。

……

	直到无序区只有一个元素为止。

（2）大根堆排序算法的基本操作：

	①建堆，建堆是不断调整堆的过程，从len/2处开始调整，一直到第一个节点，此处len是堆中元素的个数。建堆的过程是线性的过程，从len/2到0处一直调用调整堆的过程，相当于o(h1)+o(h2)…+o(hlen/2) 其中h表示节点的深度，len/2表示节点的个数，这是一个求和的过程，结果是线性的O(n)。

	②调整堆：调整堆在构建堆的过程中会用到，而且在堆排序过程中也会用到。利用的思想是比较节点i和它的孩子节点left(i),right(i)，选出三者最大(或者最小)者，如果最大（小）值不是节点i而是它的一个孩子节点，那边交互节点i和该节点，然后再调用调整堆过程，这是一个递归的过程。调整堆的过程时间复杂度与堆的深度有关系，是lgn的操作，因为是沿着深度方向进行调整的。

	③堆排序：堆排序是利用上面的两个过程来进行的。首先是根据元素构建堆。然后将堆的根节点取出(一般是与最后一个节点进行交换)，将前面len-1个节点继续进行堆调整的过程，然后再将根节点取出，这样一直到所有节点都取出。堆排序过程的时间复杂度是O(nlog_2n)。因为建堆的时间复杂度是O(n)（调用一次）；调整堆的时间复杂度是log_2n，调用了n-1次，所以堆排序的时间复杂度是O(nlog_2n)。 

	注意

	①只需做n-1趟排序，选出较大的n-1个关键字即可以使得文件递增有序。

	②用小根堆排序与利用大根堆类似，只不过其排序结果是递减有序的。堆排序和直接选择排序相反：在任何时刻堆排序中无序区总是在有序区之前，且有序区是在原向量的尾部由后往前逐步扩大至整个向量为止

堆排序的算法实现如下：

    public class HeapSort {  
            public static void main(String[] args) {  
                int[] array = { 9, 8, 7, 6, 5, 4, 3, 2, 1, 0, -1, -2, -3 };  
      
                System.out.println("Before heap:");  
                ArrayUtils.printArray(array);  
      
                heapSort(array);  
      
                System.out.println("After heap sort:");  
                ArrayUtils.printArray(array);  
            }  
      
            public static void heapSort(int[] array) {  
                if (array == null || array.length <= 1) {  
                    return;  
                }  
      
              	//建堆
                buildMaxHeap(array);  
      
                for (int i = array.length - 1; i >= 1; i--) {  
                    ArrayUtils.exchangeElements(array, 0, i);  
                    maxHeap(array, i, 0);  
                }  
            }  
      
      		//建堆函数
            private static void buildMaxHeap(int[] array) {  
                if (array == null || array.length <= 1) {  
                    return;  
                }  
      
                int half = array.length / 2;  
                for (int i = half; i >= 0; i--) {  
                    maxHeap(array, array.length, i);  
                }  
            }  
      
      		//大根堆
            private static void maxHeap(int[] array, int heapSize, int index) {  
                int left = index * 2 + 1;   
                int right = index * 2 + 2;  
      
                int largest = index;  
                if (left < heapSize && array[left] > array[index]) {  
                    largest = left;  
                } 
      
                if (right < heapSize && array[right] > array[largest]) {  
                    largest = right;  
                }  
      
                if (index != largest) {  
                    ArrayUtils.exchangeElements(array, index, largest);  
      
                    maxHeap(array, heapSize, largest);  
                }  
            }  
        }  

数组工具类；

    public class ArrayUtils {  
          
            public static void printArray(int[] array) {  
                System.out.print("{");  
                for (int i = 0; i < array.length; i++) {  
                    System.out.print(array[i]);  
                    if (i < array.length - 1) {  
                        System.out.print(", ");  
                    }  
                }  
                System.out.println("}");  
            }  
      
            public static void exchangeElements(int[] array, int index1, int index2) {  
                int temp = array[index1];  
                array[index1] = array[index2];  
                array[index2] = temp;  
            }  
        }  

	堆排序的时空复杂度和稳定性：堆排序的时间，主要由建立初始堆和反复重建堆这两部分的时间开销构成。堆排序的最好、最坏和平均情况的时间复杂度为O(n*log_2n)，空间复杂度为O(1)，它是一种不稳定的排序算法。

归并排序

	归并排序（MERGE-SORT）是建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。

	归并过程：比较a[i]和a[j]的大小，若a[i]≤a[j]，则将第一个有序表中的元素a[i]复制到r[k]中，并令i和k分别加上1；否则将第二个有序表中的元素a[j]复制到r[k]中，并令j和k分别加上1，如此循环下去，直到其中一个有序表取完，然后再将另一个有序表中剩余的元素复制到r中从下标k到下标t的单元。归并排序的算法我们通常用递归实现，先把待排序区间[s,t]以中点二分，接着把左边子区间排序，再把右边子区间排序，最后把左区间和右区间用一次归并操作合并成有序的区间[s,t]。

	归并排序的算法实现如下：

    public class MergeSortTest {  
      
        public static void main(String[] args) {  
            int[] data = new int[] { 5, 3, 6, 2, 1, 9, 4, 8, 7 };  
            print(data);  
            mergeSort(data);  
            System.out.println("排序后的数组：");  
            print(data);  
        }  
      
        public static void mergeSort(int[] data) {  
            sort(data, 0, data.length - 1);  
        }  
      
        public static void sort(int[] data, int left, int right) {  
            if (left >= right)  
                return;  
            // 找出中间索引  
            int center = (left + right) / 2;  
            // 对左边数组进行递归  
            sort(data, left, center);  
            // 对右边数组进行递归  
            sort(data, center + 1, right);  
            // 合并  
            merge(data, left, center, right);  
            print(data);  
        }  
      
        /** 
         * 将两个数组进行归并，归并前面2个数组已有序，归并后依然有序 
         *  
         * @param data 
         *            数组对象 
         * @param left 
         *            左数组的第一个元素的索引 
         * @param center 
         *            左数组的最后一个元素的索引，center+1是右数组第一个元素的索引 
         * @param right 
         *            右数组最后一个元素的索引 
         */  
        public static void merge(int[] data, int left, int center, int right) {  
            // 临时数组  
            int[] tmpArr = new int[data.length];  
            // 右数组第一个元素索引  
            int mid = center + 1;  
            // third 记录临时数组的索引  
            int third = left;  
            // 缓存左数组第一个元素的索引  
            int tmp = left;  
            while (left <= center && mid <= right) {  
                // 从两个数组中取出最小的放入临时数组  
                if (data[left] <= data[mid]) {  
                    tmpArr[third++] = data[left++];  
                } else {  
                    tmpArr[third++] = data[mid++];  
                }  
            }  
            // 剩余部分依次放入临时数组（实际上两个while只会执行其中一个）  
            while (mid <= right) {  
                tmpArr[third++] = data[mid++];  
            }  
            while (left <= center) {  
                tmpArr[third++] = data[left++];  
            }  
            // 将临时数组中的内容拷贝回原数组中  
            // （原left-right范围的内容被复制回原数组）  
            while (tmp <= right) {  
                data[tmp] = tmpArr[tmp++];  
            }  
        }  
      
        public static void print(int[] data) {  
            for (int i = 0; i < data.length; i++) {  
                System.out.print(data[i] + "\t");  
            }  
            System.out.println();  
        }  
      
    }  

	归并排序的时空复杂度和稳定性：归并排序对待排序元素的初始排列不敏感，每次划分时两个子序列的长度基本一样，因此归并排序的最好、最坏和平均时间复杂度均为O(n*longn)。merge函数的辅助空间会占用n个单元，所以空间复杂度为O(n)，归并排序是一种稳定的排序方法。

基数排序

	基数排序(Radix Sort)属于分配式排序，又称"桶子法"(Bucket Sort或Bin Sort)，将要排序的元素分配到某些"桶"中，以达到排序的作用。基数排序属于稳定的排序，其时间复杂度为nlog(r)m (其中r为的采取的基数,m为堆数)，基数排序的效率有时候高于其它比较性排序。

	基数排序的方式可以采用最低位优先LSD（Least sgnificant digital）法或最高位优先MSD（Most sgnificant digital）法，LSD的排序方式由键值的最右边开始，而MSD则相反，由键值的最左边开始。LSD的基数排序适用于位数小的数列，如果位数多的话，使用MSD的效率会比较好，MSD的方式恰与LSD相反，是由高位数为基底开始进行分配，其他的演算方式则都相同。

	基数排序的实现算法如下：

    import java.util.Arrays;  
      
    public class MultiKeyRadixSortTest {  
      
        public static void main(String[] args) {  
            int[] data = new int[] { 1100, 192, 221, 12, 23 };  
            print(data);  
            radixSort(data, 10, 4);  
            System.out.println("排序后的数组：");  
            print(data);  
        }  
      
        public static void radixSort(int[] data, int radix, int d) {  
            // 缓存数组  
            int[] tmp = new int[data.length];  
            // buckets用于记录待排序元素的信息  
            // buckets数组定义了max-min个桶  
            int[] buckets = new int[radix];  
      
            for (int i = 0, rate = 1; i < d; i++) {  
      
                // 重置count数组，开始统计下一个关键字  
                Arrays.fill(buckets, 0);  
                // 将data中的元素完全复制到tmp数组中  
                System.arraycopy(data, 0, tmp, 0, data.length);  
      
                // 计算每个待排序数据的子关键字  
                for (int j = 0; j < data.length; j++) {  
                    int subKey = (tmp[j] / rate) % radix;  
                    buckets[subKey]++;  
                }  
      
                for (int j = 1; j < radix; j++) {  
                    buckets[j] = buckets[j] + buckets[j - 1];  
                }  
      
                // 按子关键字对指定的数据进行排序  
                for (int m = data.length - 1; m >= 0; m--) {  
                    int subKey = (tmp[m] / rate) % radix;  
                    data[--buckets[subKey]] = tmp[m];  
                }  
                rate *= radix;  
            }  
      
        }  
      
        public static void print(int[] data) {  
            for (int i = 0; i < data.length; i++) {  
                System.out.print(data[i] + "\t");  
            }  
            System.out.println();  
        }  
      
    }  

	基数排序的时空复杂度和稳定性：基数排序的最好、最坏和平均情况下的时间复杂度都是O(d(r+n))，空间复杂度是O(rd+n)，其中r代表关键字基数，d代表长度，n代表关键字个数，基数排序是一种稳定的排序算法。

计数排序

	当输入的元素是n个0到k之间的整数时，它的运行时间是Θ(n + k)。计数排序不是比较排序，排序的速度快于任何比较排序算法。

	由于用来计数的数组C的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上1），这使得计数排序对于数据范围很大的数组，需要大量时间和内存。例如：计数排序是用来排序0到100之间的数字的最好的算法，但是它不适合按字母顺序排序人名。但是，计数排序可以用在基数排序算法中，能够更有效的排序数据范围很大的数组。

	通俗地理解，例如有10个年龄不同的人，统计出有8个人的年龄比A小，那A的年龄就排在第9位，用这个方法可以得到其他每个人的位置，也就排好了序。当然，年龄有重复时需要特殊处理（保证稳定性），这就是为什么最后要反向填充目标数组，以及将每个数字的统计减去1的原因。算法的步骤如下：

1. 找出待排序的数组中最大和最小的元素
2. 统计数组中每个值为i的元素出现的次数，存入数组 C 的第 i 项
3. 对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）
4. 反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1

Java代码

    /**
     * Created by Feng on 2017/4/12.
     * 算法步骤
     * 1.找出待排序的数组中最大和最小的元素
     * 2.统计数组中每个值为i的元素出现的次数，存入数组 C 的第 i 项
     * 3.对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）
     * 4.反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1
     */
    public class CountSort {
        public static void main(String[] args) {
            //排序的数组
            int a[] = {1, 5, 6, 3, 8};
            int b[] = countSort(a);
            for (int i : b) {
                System.out.print(i + "");
            }
            System.out.println();
        }
    
        public static int[] countSort(int[] a) {
            int b[] = new int[a.length];
            int max = a[0], min = a[0];
            for (int i : a) {
                if (i > max) {
                    max = i;
                }
                if (i < min) {
                    min = i;
                }
            }
            //这里k的大小是要排序的数组中，元素大小的极值差+1
            int k = max - min + 1;
            int c[] = new int[k];
            for (int i = 0; i < a.length; ++i) {
                c[a[i] - min] += 1;//优化过的地方，减小了数组c的大小,统计每个数出现的次数
            }
            for (int i = 1; i < c.length; ++i) {
                c[i] = c[i] + c[i - 1];
            }
            for (int i = a.length - 1; i >= 0; --i) {
                b[--c[a[i] - min]] = a[i];//按存取的方式取出c的元素
            }
            return b;
        }
    }

不同排序算法的比较



	从时间上看，简单选择排序、直接插入插叙和冒泡排序在平均情况下的时间复杂度都为O(n^2)，但实现过程较为简单，直接插入排序和冒泡排序在最好情况下的时间复杂度可以达到O(n)，而简单选择排序则与序列状态无关。希尔排序作为插入排序的发展，对较大规模的排序都能达到很高的效率，但目前未得出其精确的渐近时间。堆排序是利用了称为堆的数据结构，可以再线性时间内完成建堆，并在O(n*long_2n)内完成排序过程。快速排序是基于分治的思想，虽然在最坏情况下快速排序的时间复杂度会达到O(n^2)，但是快速排序平均性能可以达到O(nlog_2n)，在实际应用中常优于其他排序算法。归并排序同样也是基于分治的思想，但由于其分割子序列与初始状态无关，因此它的最好、最坏和平均时间复杂度均为O(nlong_2n)。

	从空间上看，简单选择排序、插入排序、冒泡排序、希尔排序和堆排序都仅需要常数个辅助空间。快速排序在空间上只使用一个小的辅助栈，用于实现递归，平均情况下为O(log_2n)，在最坏情况下可能会增长到O(n)。二路归并排序在合并操作中需要较多的辅助空间用于元素复制，大小为O(n)。

	从稳定性上看，插入排序、冒泡排序、归并排序和基数排序是稳定的排序方法，而简单选择排序、快速排序、希尔排序和堆排序都是不稳定的排序方法。

小结

1. 若n(n≤50)较小，则可以采用直接插入排序或简单选择排序。由于直接插入排序所需要的记录移动操作比简单选择排序多，因而当记录本身信息量较大时，用简单选择排序比较好。
2. 若文件的初始状态已按关键字基本有序，则选用直接输入排序和冒泡排序为好。
3. 若n较大，则应采用时间复杂度为O(nlog_2n)排序方法：快速排序、堆排序或归并排序。快速排序被认为是目前基于比较的内部排序算法中最好的算法，当待排序的关键字随机分布时，快速排序的平均时间最短。堆排序所需的辅助空间少于快速排序，并且不会出现快速排序可能出现的最坏情况。这两种排序方法都不是稳定的。若要求排序稳定则可选用归并排序。通常将归并排序和插入排序结合在一起使用，先利用直接插入排序求得较长的有序子序列，然后两两归并。因为直接插入排序是稳定的，所以改进后的归并排序仍然是稳定的。
4. 再基于比较的排序方法中，每次比较两个关键字的大小之后，仅仅会出现两种可能的转移，因此可以用一棵二叉树来描述比较判定过程。由此可以证明：当文件的n个关键字随机分布时，任何借助于比较的排序算法，至少需要O(nlog_2n)的时间。
5. 若n很大，记录的关键字位数较少且可以分解时，采用基数排序比较好。
6. 当记录本身信息量较大时，为避免耗费大量的移动时间，可用链表作为存储结构。

数据结构之图论

图的定义

	图是一种复杂的非线性结构。在线性结构中，数据元素之间满足唯一的线性关系，每个数据元素(除第一个和最后一个外)只有一个直接前趋和一个直接后继；在树形结构中，数据元素之间有着明显的层次关系，并且每个数据元素只与上一层中的一个元素(双亲节点)及下一层的多个元素(孩子节点)相关；而在图形结构中，节点之间的关系是任意的，图中任意两个数据元素之间都有可能相关。图G由两个集合V(顶点Vertex)和E(边Edge)组成，定义为G=(V，E)。

图的存储结构

	图的信息包括两部分：图中定点的信息以及描述定点之间的关系——边的信息。图通常有两种表示方法：邻接矩阵和邻接表，前者属于图的顺序存储结构，后者属于图的链接存储结构。

邻接矩阵

	图的邻接矩阵（Adjacency Matrix)存储方式是用两个数组来表示图。一个一维的数组存储图中顶点信息，一个二维数组（称为邻接矩阵）存储图中的边或弧的信息。设G=(V,E)是具有n个顶点的图，若(vi,vj)属于Ｅ，则对应Ｇ的邻接矩阵中的元素A[i][j] = wij 或1,否则，Ａ[i][j] = 0或无穷大,其中，wij可以指边的权重。

	图的邻接矩阵表示具有以下特点：

1. 无向图的临街矩阵一定是一个对称矩阵(并且唯一)。因此，在实际存储邻接矩阵时只需存储上(或下)三角矩阵的元素即可。
2. 对于无向图，邻接矩阵的第i行(或第i列)非零元素的个数正好是第i个定点的度TD(Vi)。
3. 对于有向图，邻接矩阵的第i行(或第i列)非零元素的个数正好是第i个顶点的出度OD(Vi)或入度TD(Vi)。
4. 用邻接矩阵存储图，很容易确定图中任意两个顶点之间是否有边相连。但是，要确定图中有多少条边，则必须按行、列队每个元素进行检测，所花费的时间代价很大。
5. 邻接矩阵的空间复杂度为O(n^2)，其中n为图的定点数|V|，因此邻接矩阵适合存储稠密图。

以下是一个无向图的邻接矩阵表示示例：



邻接矩阵的Java实现

	邻接矩阵模型类的类名为AMWGraph.java，能够通过该类构造一个邻接矩阵表示的图，且提供插入结点，插入边，取得某一结点的第一个邻接结点和下一个邻接结点。

    import java.util.ArrayList;
    import java.util.LinkedList;
    /**
     * @description 邻接矩阵模型类
     * @author beanlam
     * @time 2015.4.17 
     */
    public class AMWGraph {
        private ArrayList vertexList;//存储点的链表
        private int[][] edges;//邻接矩阵，用来存储边
        private int numOfEdges;//边的数目
    
        public AMWGraph(int n) {
            //初始化矩阵，一维数组，和边的数目
            edges=new int[n][n];
            vertexList=new ArrayList(n);
            numOfEdges=0;
        }
    
        //得到结点的个数
        public int getNumOfVertex() {
            return vertexList.size();
        }
    
        //得到边的数目
        public int getNumOfEdges() {
            return numOfEdges;
        }
    
        //返回结点i的数据
        public Object getValueByIndex(int i) {
            return vertexList.get(i);
        }
    
        //返回v1,v2的权值
        public int getWeight(int v1,int v2) {
            return edges[v1][v2];
        }
    
        //插入结点
        public void insertVertex(Object vertex) {
            vertexList.add(vertexList.size(),vertex);
        }
    
        //插入结点
        public void insertEdge(int v1,int v2,int weight) {
            edges[v1][v2]=weight;
            numOfEdges++;
        }
    
        //删除结点
        public void deleteEdge(int v1,int v2) {
            edges[v1][v2]=0;
            numOfEdges--;
        }
    
        //得到第一个邻接结点的下标
        public int getFirstNeighbor(int index) {
            for(int j=0;j<vertexList.size();j++) {
                if (edges[index][j]>0) {
                    return j;
                }
            }
            return -1;
        }
    
        //根据前一个邻接结点的下标来取得下一个邻接结点
        public int getNextNeighbor(int v1,int v2) {
            for (int j=v2+1;j<vertexList.size();j++) {
                if (edges[v1][j]>0) {
                    return j;
                }
            }
            return -1;
        }
    }

邻接表

	邻接表是对图G中的每个顶点Vi，将所有的邻接于Vi的顶点链成一个单链表，这个单链表就称为顶点Vi的边表(对于有向图则称为出边表)，边表的头指针和顶点的数据信息采用顺序存储结构(称为顶点表)。所以，在邻接表中存在两种结点：顶点表结点和边表结点。如图所示：



	图的邻接表存储结构描述如下：

    #define MAX_VERTEX_NUM 100
    #define OK 1
    #define ERROR 0
    
    typedef char VertexType;
    //typedef int InfoType;
    typedef int Status;
    
    typedef int QElemType;
    
    //边表
    typedef struct ArcNode
    {
        int adjvex; //该边所指顶点位置
        struct ArcNode *nextarc; //指向下一条弧的指针
        //InfoType *info; //该弧相关信息的指针
    } ArcNode;
    
    //顶点表
    typedef struct VerNode
    {
        VertexType data; //顶点信息
        ArcNode *firstarc; //指向第一条依附该顶点的弧
    } VerNode, AdjList[MAX_VERTEX_NUM];
    
    //图定义
    typedef struct
    {
        AdjList vertices;
        int vexnum, arcnum; //图的当前顶点数和弧数
        //int kind; //图的种类标志
    } ALGraph;

图的邻接表存储方法具有以下特点：

1. 对于图G=(V，E)，如果G为无向图，则需要的存储空间为O(|V|+2|E|)；如果G为无向图，则所需要的存储空间为O(|V|+|E|)。前者的倍数2是由于无向图中，每条边在邻接表中出现了两次。
2. 对于稀疏图，采用邻接表表示将大大节省存储空间。
3. 在邻接表中，给定一顶点，能很容易地找出它的所有邻边，只需读取它的邻接表即可。在邻接矩阵中，相同的操作则需要扫描一行，花费的时间为O(n)。但若要确定给定的两个顶点之间是否存在边，在邻接矩阵里可以立刻查到，而在邻接表中则需要在相应节点对应的边表中查找另一个节点。
4. 在有向图的邻接表表示中，求一个给定顶点的出度只需要计算其邻接表中的结点个数即可；但求其顶点的入度，则需要遍历全部的邻接表。因此，也有人采用邻接表的存储方式来加速求解给定顶点的入度。当然，这实际上余邻接表的存储类似。
5. 图的邻接表表示不唯一，这是因为在每个顶点对应的单链表中，各边节点的链接次序可以是任意的，取决于建立邻接表的算法以及边的输入次序。

邻接表的Java实现

    public class ListUDG {  
        int vlen; // 顶点个数  
        int elen; // 边个数  
        VertexNode[] vertexNodeList; // 顶点数组  
        EdgeNode edgeNode;  
      
        /** 
         * 构造函数 
         * @param vexs 
         * @param edges 
         */  
        public ListUDG(char[] vexs, char[][] edges) {  
            vlen = vexs.length;  
            elen = edges.length;  
      
            // 初始化顶点,建立顶点表  
            vertexNodeList = new VertexNode[vlen];  
            for (int i = 0; i < vlen; i++) {  
                vertexNodeList[i] = new VertexNode();  
                vertexNodeList[i].vertex = vexs[i];  
                vertexNodeList[i].firstedge = null;  
            }  
      
            // 初始化边，利用头插法建立邻接表  
            for (int i = 0; i < elen; i++) {  
                EdgeNode edgeNode_1 = new EdgeNode();  
                EdgeNode edgeNode_2 = new EdgeNode();  
                int vi = getPosition(edges[i][0], vexs);  
                int vj = getPosition(edges[i][1], vexs);  
                   
                edgeNode_1.adjvex = edges[i][1];  
                edgeNode_1.next = vertexNodeList[vi].firstedge;  
                vertexNodeList[vi].firstedge = edgeNode_1;  
      
                edgeNode_2.adjvex = edges[i][0];  
                edgeNode_2.next = vertexNodeList[vj].firstedge;  
                vertexNodeList[vj].firstedge = edgeNode_2;  
            }  
        }  
      
        /** 
         *  顶点表结点 
         */  
        private class VertexNode {  
            char vertex; // 顶点域，存储顶点信息  
            EdgeNode firstedge; // 边表头指针  
        }  
      
        /** 
         *  边表结点 
         */  
        private class EdgeNode {  
            char adjvex; // 邻接点域，存储该顶点对应的下标  
            EdgeNode next; // 链域，指向下一个邻接点  
        }  
      
        /** 
         *  返回ch位置 
         */  
        private int getPosition(char ch, char[] vexs) {  
            for (int i = 0; i < vlen; i++)  
                if (vexs[i] == ch)  
                    return i;  
            return -1;  
        }  
      
        /** 
         *  打印邻接表 
         */  
        public void print() {  
            System.out.printf("AdjList:\n");  
            for (int i = 0; i < vlen; i++) {  
                System.out.print(vertexNodeList[i].vertex + "-->");  
                if (vertexNodeList[i].firstedge != null) {  
                    EdgeNode mEdgeNode = new EdgeNode();  
                    mEdgeNode = vertexNodeList[i].firstedge;  
                    System.out.print(mEdgeNode.adjvex);  
                    while (mEdgeNode.next != null) {  
                        mEdgeNode = mEdgeNode.next;  
                        System.out.print(mEdgeNode.adjvex);  
                    }  
                    System.out.print("\n");  
                } else {  
                    System.out.print("\n");  
                }  
            }  
        }  
      
        /** 
         * 主函数 
         * @param args 
         */  
        public static void main(String args[]) {  
            // 顶点数组  
            char[] vexs = {  
                'A', 'B', 'C', 'D'  
            };  
            // 边数组  
            char[][] edges = new char[][] {  
                {  
                    'A', 'B'  
                }, {  
                    'A', 'C'  
                }, {  
                    'A', 'D'  
                }, {  
                    'B', 'D'  
                }, {  
                    'C', 'D'  
                }  
            };  
      
            ListUDG listUDG = new ListUDG(vexs, edges);  
            listUDG.print();  
        }  
    }  

图的创建

    int visit[MAX_VERTEX_NUM];
    
    //节点元素定位
    int LocateVex(ALGraph *G, VertexType e)
    {
        int tmp = -1; int i;
        for (i = 0; i < G->vexnum; i++)
        {
            if (G->vertices[i].data == e)
            {
                tmp = i; break;
            }
        }
        return tmp;
    }
    
    //邻接表头插
    Status HeadInsertArc(ALGraph *G, int pos, int adjvex)
    {
        ArcNode *e;
        e = (ArcNode *)malloc(sizeof(ArcNode));
        e->adjvex = adjvex;
        e->nextarc = G->vertices[pos].firstarc;
        G->vertices[pos].firstarc = e;
        return OK;
    }
    
    //邻接表尾插
    Status TailInsertArc(ALGraph *G, int pos, int adjvex)
    {
        ArcNode *e, *p;
        e = (ArcNode *)malloc(sizeof(ArcNode));
        e->adjvex = adjvex;
        e->nextarc = NULL;
        if (G->vertices[pos].firstarc == NULL)
            G->vertices[pos].firstarc = e;
        else
        {
            p = G->vertices[pos].firstarc;
            while (p->nextarc)
                p = p->nextarc;
            p->nextarc = e;
        }
        return OK;
    }
    
    //创建图
    Status CreateGraph(ALGraph *G)
    {
        int i;
        printf("Please input the vexnum and arcnum:");
        scanf("%d%d", &(G->vexnum), &(G->arcnum));
        getchar();
        for (i = 0; i < G->vexnum; i++)
        {
            G->vertices[i].data = getchar();
            G->vertices[i].firstarc = NULL;
        }
        getchar();
        for (i = 0; i < G->arcnum; i++)
        {
            char arc_s, arc_e;
            arc_s = getchar(); arc_e = getchar();
            int v_s = LocateVex(G, arc_s);
            int v_e = LocateVex(G, arc_e);
            //HeadInsertArc(G, v_s, v_e);
            //HeadInsertArc(G, v_e, v_s);
            TailInsertArc(G, v_s, v_e);
            TailInsertArc(G, v_e, v_s);
        }
        return OK;
    }
    
    //打印节点
    Status printVex(ALGraph *G)
    {
        ArcNode *p; int i;
        for (i = 0; i < G->vexnum; i++)
        {
            printf("%d | %c", i, G->vertices[i].data);
            if (G->vertices[i].firstarc != NULL)
            {
                p = G->vertices[i].firstarc;
                while (p)
                {
                    printf("-->%c", G->vertices[p->adjvex].data);
                    p = p->nextarc;
                }
            }
            printf("\n");
        }
        return OK;
    }

图的遍历

	从图中某一顶点出发，按某种搜索方法访遍其余节点，且使每一项顶点仅被访问一次，这一过程称为图的遍历。图的常用遍历方法有两种：深度优先搜索(DFS)和广度优先搜索。

深度优先搜索

	在G中任选一顶点v为初始出发点(源点)，则深度优先遍历可定义如下：首先访问出发点v，并将其标记为已访问过；然后依次从v出发搜索v的每个邻接点w。若w未曾访问过，则以w为新的出发点继续进行深度优先遍历，直至图中所有和源点v有路径相通的顶点(亦称为从源点可达的顶点)均已被访问为止。若此时图中仍有未访问的顶点，则另选一个尚未访问的顶点作为新的源点重复上述过程，直至图中所有顶点均已被访问为止。

具体算法表述如下：

1. 访问初始结点v，并标记结点v为已访问。
2. 查找结点v的第一个邻接结点w。
3. 若w存在，则继续执行4，否则算法结束。
4. 若w未被访问，对w进行深度优先遍历递归（即把w当做另一个v，然后进行步骤123）。
5. 查找结点v的w邻接结点的下一个邻接结点，转到步骤3

例如下图，其深度优先遍历顺序为 1->2->4->8->5->3->6->7



深度优先搜索的Java实现——基于邻接矩阵

    import java.util.ArrayList;
    import java.util.LinkedList;
    /**
     * @description 邻接矩阵模型类
     * @author beanlam
     * @time 2015.4.17 
     */
    public class AMWGraph {
        private ArrayList vertexList;//存储点的链表
        private int[][] edges;//邻接矩阵，用来存储边
        private int numOfEdges;//边的数目
    
        public AMWGraph(int n) {
            //初始化矩阵，一维数组，和边的数目
            edges=new int[n][n];
            vertexList=new ArrayList(n);
            numOfEdges=0;
        }
    
        //得到结点的个数
        public int getNumOfVertex() {
            return vertexList.size();
        }
    
        //得到边的数目
        public int getNumOfEdges() {
            return numOfEdges;
        }
    
        //返回结点i的数据
        public Object getValueByIndex(int i) {
            return vertexList.get(i);
        }
    
        //返回v1,v2的权值
        public int getWeight(int v1,int v2) {
            return edges[v1][v2];
        }
    
        //插入结点
        public void insertVertex(Object vertex) {
            vertexList.add(vertexList.size(),vertex);
        }
    
        //插入结点
        public void insertEdge(int v1,int v2,int weight) {
            edges[v1][v2]=weight;
            numOfEdges++;
        }
    
        //删除结点
        public void deleteEdge(int v1,int v2) {
            edges[v1][v2]=0;
            numOfEdges--;
        }
    
        //得到第一个邻接结点的下标
        public int getFirstNeighbor(int index) {
            for(int j=0;j<vertexList.size();j++) {
                if (edges[index][j]>0) {
                    return j;
                }
            }
            return -1;
        }
    
        //根据前一个邻接结点的下标来取得下一个邻接结点
        public int getNextNeighbor(int v1,int v2) {
            for (int j=v2+1;j<vertexList.size();j++) {
                if (edges[v1][j]>0) {
                    return j;
                }
            }
            return -1;
        }
        
        //私有函数，深度优先遍历
        private void depthFirstSearch(boolean[] isVisited,int  i) {
            //首先访问该结点，在控制台打印出来
            System.out.print(getValueByIndex(i)+"  ");
            //置该结点为已访问
            isVisited[i]=true;
            
            int w=getFirstNeighbor(i);//
            while (w!=-1) {
                if (!isVisited[w]) {
                    depthFirstSearch(isVisited,w);
                }
                w=getNextNeighbor(i, w);
            }
        }
        
        //对外公开函数，深度优先遍历，与其同名私有函数属于方法重载
        public void depthFirstSearch() {
            for(int i=0;i<getNumOfVertex();i++) {
                //因为对于非连通图来说，并不是通过一个结点就一定可以遍历所有结点的。
                if (!isVisited[i]) {
                    depthFirstSearch(isVisited,i);
                }
            }
        }

广度优先搜索

	从图中某个顶点V0出发，并访问此顶点；然后访问V0的各个未曾访问的邻接点W1，W2，…,Wk;然后,依次从W1,W2,…,Wk出发访问各自未被访问的邻接点；重复步骤第二个步骤，直到全部顶点都被访问为止。

具体算法表述如下：

1. 访问初始结点v并标记结点v为已访问。
2. 结点v入队列
3. 当队列非空时，继续执行，否则算法结束。
4. 出队列，取得队头结点u。
5. 查找结点u的第一个邻接结点w。
6. 若结点u的邻接结点w不存在，则转到步骤3；否则循环执行以下三个步骤：
       1). 若结点w尚未被访问，则访问结点w并标记为已访问。
       2). 结点w入队列
       3). 查找结点u的继w邻接结点后的下一个邻接结点w，转到步骤6。

如下图，其广度优先算法的遍历顺序为：1->2->3->4->5->6->7->8



深度优先搜索的Java实现——基于邻接矩阵

    import java.util.ArrayList;
    import java.util.LinkedList;
    /**
     * @description 邻接矩阵模型类
     * @author beanlam
     * @time 2015.4.17 
     */
    public class AMWGraph {
        private ArrayList vertexList;//存储点的链表
        private int[][] edges;//邻接矩阵，用来存储边
        private int numOfEdges;//边的数目
    
        public AMWGraph(int n) {
            //初始化矩阵，一维数组，和边的数目
            edges=new int[n][n];
            vertexList=new ArrayList(n);
            numOfEdges=0;
        }
    
        //得到结点的个数
        public int getNumOfVertex() {
            return vertexList.size();
        }
    
        //得到边的数目
        public int getNumOfEdges() {
            return numOfEdges;
        }
    
        //返回结点i的数据
        public Object getValueByIndex(int i) {
            return vertexList.get(i);
        }
    
        //返回v1,v2的权值
        public int getWeight(int v1,int v2) {
            return edges[v1][v2];
        }
    
        //插入结点
        public void insertVertex(Object vertex) {
            vertexList.add(vertexList.size(),vertex);
        }
    
        //插入结点
        public void insertEdge(int v1,int v2,int weight) {
            edges[v1][v2]=weight;
            numOfEdges++;
        }
    
        //删除结点
        public void deleteEdge(int v1,int v2) {
            edges[v1][v2]=0;
            numOfEdges--;
        }
    
        //得到第一个邻接结点的下标
        public int getFirstNeighbor(int index) {
            for(int j=0;j<vertexList.size();j++) {
                if (edges[index][j]>0) {
                    return j;
                }
            }
            return -1;
        }
    
        //根据前一个邻接结点的下标来取得下一个邻接结点
        public int getNextNeighbor(int v1,int v2) {
            for (int j=v2+1;j<vertexList.size();j++) {
                if (edges[v1][j]>0) {
                    return j;
                }
            }
            return -1;
        }
        
        //私有函数，广度优先遍历
        private void broadFirstSearch(boolean[] isVisited,int i) {
            int u,w;
            LinkedList queue=new LinkedList();
            
            //访问结点i
            System.out.print(getValueByIndex(i)+"  ");
            isVisited[i]=true;
            //结点入队列
            queue.addlast(i);
            while (!queue.isEmpty()) {
                u=((Integer)queue.removeFirst()).intValue();
                w=getFirstNeighbor(u);
                while(w!=-1) {
                    if(!isVisited[w]) {
                            //访问该结点
                            System.out.print(getValueByIndex(w)+"  ");
                            //标记已被访问
                            isVisited[w]=true;
                            //入队列
                            queue.addLast(w);
                    }
                    //寻找下一个邻接结点
                    w=getNextNeighbor(u, w);
                }
            }
        }
        
        //对外公开函数，广度优先遍历
        public void broadFirstSearch() {
            for(int i=0;i<getNumOfVertex();i++) {
                if(!isVisited[i]) {
                    broadFirstSearch(isVisited, i);
                }
            }
        }
    }

	遍历图的过程实质上是对每个顶点查找其邻接点的过程，其耗费的时间则取决于所采用的存储结构。当以邻接矩阵表示时，查找每个顶点的邻接点所需时间O(n)，故总的时间复杂度为O(n^2)。当以邻接表表示时，查找每个顶点的邻接点所时间为O(e)，而每个顶点均要入栈一次，因此总的时间复杂度为O(n+e)。深度优先搜索是递归算法，算法执行需要借助一个递归工作栈，它的空间复杂度为O(n)。广度优先搜索的时间复杂度和深度优先搜索相同，两者的不同之处仅仅在于对顶点访问的顺序不同。

	在连通图的深度遍历过程中，可以得到一棵遍历树，称为深度优先生成树。对不连通图进行深度优先搜索，则可以得到深度优先生成森林。而广度优先搜索则会产生一颗广度优先生成树。

	注意：一给定图的邻接矩阵表示是唯一的，故其深度(广度)优先生成树是唯一的；邻接表存储表示是不唯一的，其深度(广度)优先生成树是不唯一的。但对于已给定邻接表存储的图(即遍历顺序已确定)，则其深度(广度)优先生成树是唯一的。

图的应用

最短路径

迪杰斯特拉算法

	迪杰斯特拉(Dijkstra)算法是典型最短路径算法，用于计算一个节点到其他节点的最短路径。它的主要特点是以起始点为中心向外层层扩展(广度优先搜索思想)，直到扩展到终点为止。

基本思想

	通过Dijkstra计算图G中的最短路径时，需要指定起点s(即从顶点s开始计算)。此外，引进两个集合S和U。S的作用是记录已求出最短路径的顶点(以及相应的最短路径长度)，而U则是记录还未求出最短路径的顶点(以及该顶点到起点s的距离)。初始时，S中只有起点s；U中是除s之外的顶点，并且U中顶点的路径是"起点s到该顶点的路径"。然后，从U中找出路径最短的顶点，并将其加入到S中；接着，更新U中的顶点和顶点对应的路径。 然后，再从U中找出路径最短的顶点，并将其加入到S中；接着，更新U中的顶点和顶点对应的路径。 ... 重复该操作，直到遍历完所有顶点。

操作步骤

(1) 初始时，S只包含起点s；U包含除s外的其他顶点，且U中顶点的距离为"起点s到该顶点的距离"[例如，U中顶点v的距离为(s,v)的长度，然后s和v不相邻，则v的距离为∞]。

(2) 从U中选出"距离最短的顶点k"，并将顶点k加入到S中；同时，从U中移除顶点k。

(3) 更新U中各个顶点到起点s的距离。之所以更新U中顶点的距离，是由于上一步中确定了k是求出最短路径的顶点，从而可以利用k来更新其它顶点的距离；例如，(s,v)的距离可能大于(s,k)+(k,v)的距离。

(4) 重复步骤(2)和(3)，直到遍历完所有顶点。

以下图为例：



以上图G4为例，来对迪杰斯特拉进行算法演示(以第4个顶点D为起点)。



初始状态：S是已计算出最短路径的顶点集合，U是未计算除最短路径的顶点的集合！ 

第1步：将顶点D加入到S中。 

    此时，S={D(0)}, U={A(∞),B(∞),C(3),E(4),F(∞),G(∞)}。     注:C(3)表示C到起点D的距离是3。

第2步：将顶点C加入到S中。 

    上一步操作之后，U中顶点C到起点D的距离最短；因此，将C加入到S中，同时更新U中顶点的距离。以顶点F为例，之前F到D的距离为∞；但是将C加入到S之后，F到D的距离为9=(F,C)+(C,D)。 

    此时，S={D(0),C(3)}, U={A(∞),B(13),E(4),F(9),G(∞)}。

第3步：将顶点E加入到S中。 

    上一步操作之后，U中顶点E到起点D的距离最短；因此，将E加入到S中，同时更新U中顶点的距离。还是以顶点F为例，之前F到D的距离为9；但是将E加入到S之后，F到D的距离为6=(F,E)+(E,D)。 

    此时，S={D(0),C(3),E(4)}, U={A(∞),B(13),F(6),G(12)}。

第4步：将顶点F加入到S中。 

    此时，S={D(0),C(3),E(4),F(6)}, U={A(22),B(13),G(12)}。

第5步：将顶点G加入到S中。 

    此时，S={D(0),C(3),E(4),F(6),G(12)}, U={A(22),B(13)}。

第6步：将顶点B加入到S中。 

    此时，S={D(0),C(3),E(4),F(6),G(12),B(13)}, U={A(22)}。

第7步：将顶点A加入到S中。 

    此时，S={D(0),C(3),E(4),F(6),G(12),B(13),A(22)}。

此时，起点D到各个顶点的最短距离就计算出来了：A(22) B(13) C(3) D(0) E(4) F(6) G(12)。

Java: Dijkstra算法获取最短路径(邻接表):

    import java.io.IOException;
    import java.util.Scanner;
    
    public class ListUDG {
        private static int INF = Integer.MAX_VALUE;
    
        // 邻接表中表对应的链表的顶点
        private class ENode {
            int ivex;       // 该边所指向的顶点的位置
            int weight;     // 该边的权
            ENode nextEdge; // 指向下一条弧的指针
        }
    
        // 邻接表中表的顶点
        private class VNode {
            char data;          // 顶点信息
            ENode firstEdge;    // 指向第一条依附该顶点的弧
        };
    
        private int mEdgNum;    // 边的数量
        private VNode[] mVexs;  // 顶点数组
    
        /*
         * 创建图(用已提供的矩阵)
         *
         * 参数说明：
         *     vexs  -- 顶点数组
         *     edges -- 边
         */
        public ListUDG(char[] vexs, EData[] edges) {
            
            // 初始化"顶点数"和"边数"
            int vlen = vexs.length;
            int elen = edges.length;
    
            // 初始化"顶点"
            mVexs = new VNode[vlen];
            for (int i = 0; i < mVexs.length; i++) {
                mVexs[i] = new VNode();
                mVexs[i].data = vexs[i];
                mVexs[i].firstEdge = null;
            }
    
            // 初始化"边"
            mEdgNum = elen;
            for (int i = 0; i < elen; i++) {
                // 读取边的起始顶点和结束顶点
                char c1 = edges[i].start;
                char c2 = edges[i].end;
                int weight = edges[i].weight;
    
                // 读取边的起始顶点和结束顶点
                int p1 = getPosition(c1);
                int p2 = getPosition(c2);
                // 初始化node1
                ENode node1 = new ENode();
                node1.ivex = p2;
                node1.weight = weight;
                // 将node1链接到"p1所在链表的末尾"
                if(mVexs[p1].firstEdge == null)
                  mVexs[p1].firstEdge = node1;
                else
                    linkLast(mVexs[p1].firstEdge, node1);
                // 初始化node2
                ENode node2 = new ENode();
                node2.ivex = p1;
                node2.weight = weight;
                // 将node2链接到"p2所在链表的末尾"
                if(mVexs[p2].firstEdge == null)
                  mVexs[p2].firstEdge = node2;
                else
                    linkLast(mVexs[p2].firstEdge, node2);
            }
        }
    
        /*
         * 将node节点链接到list的最后
         */
        private void linkLast(ENode list, ENode node) {
            ENode p = list;
    
            while(p.nextEdge!=null)
                p = p.nextEdge;
            p.nextEdge = node;
        }
    
        /*
         * 返回ch位置
         */
        private int getPosition(char ch) {
            for(int i=0; i<mVexs.length; i++)
                if(mVexs[i].data==ch)
                    return i;
            return -1;
        }
    
        /*
         * 读取一个输入字符
         */
        private char readChar() {
            char ch='0';
    
            do {
                try {
                    ch = (char)System.in.read();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            } while(!((ch>='a'&&ch<='z') || (ch>='A'&&ch<='Z')));
    
            return ch;
        }
    
        /*
         * 读取一个输入字符
         */
        private int readInt() {
            Scanner scanner = new Scanner(System.in);
            return scanner.nextInt();
        }
        
         /*
         * 打印矩阵队列图
         */
        public void print() {
            System.out.printf("List Graph:\n");
            for (int i = 0; i < mVexs.length; i++) {
                System.out.printf("%d(%c): ", i, mVexs[i].data);
                ENode node = mVexs[i].firstEdge;
                while (node != null) {
                    System.out.printf("%d(%c) ", node.ivex, mVexs[node.ivex].data);
                    node = node.nextEdge;
                }
                System.out.printf("\n");
            }
        }
        
         /*
         * 获取边<start, end>的权值；若start和end不是连通的，则返回无穷大。
         */
        private int getWeight(int start, int end) {
    
            if (start==end)
                return 0;
    
            ENode node = mVexs[start].firstEdge;
            while (node!=null) {
                if (end==node.ivex)
                    return node.weight;
                node = node.nextEdge;
            }
    
            return INF;
        }
    
        /*
         * Dijkstra最短路径。
         * 即，统计图中"顶点vs"到其它各个顶点的最短路径。
         *
         * 参数说明：
         *       vs -- 起始顶点(start vertex)。即计算"顶点vs"到其它顶点的最短路径。
         *     prev -- 前驱顶点数组。即，prev[i]的值是"顶点vs"到"顶点i"的最短路径所经历的全部顶点中，位于"顶点i"之前的那个顶点。
         *     dist -- 长度数组。即，dist[i]是"顶点vs"到"顶点i"的最短路径的长度。
         */
        public void dijkstra(int vs, int[] prev, int[] dist) {
            // flag[i]=true表示"顶点vs"到"顶点i"的最短路径已成功获取。
            boolean[] flag = new boolean[mVexs.length];
            
            // 初始化
            for (int i = 0; i < mVexs.length; i++) {
                flag[i] = false;            // 顶点i的最短路径还没获取到。
                prev[i] = 0;                // 顶点i的前驱顶点为0。
                dist[i] = getWeight(vs, i); // 顶点i的最短路径为"顶点vs"到"顶点i"的权。
            }
    
            // 对"顶点vs"自身进行初始化
            flag[vs] = true;
            dist[vs] = 0;
    
            // 遍历mVexs.length-1次；每次找出一个顶点的最短路径。
            int k = 0;
            for (int i = 1; i < mVexs.length; i++) {
                // 寻找当前最小的路径；
                // 即，在未获取最短路径的顶点中，找到离vs最近的顶点(k)。
                int min = INF;
                for (int j = 0; j < mVexs.length; j++) {
                    if (flag[j]==false && dist[j]<min) {
                        min = dist[j];
                        k = j;
                    }
                }
                // 标记"顶点k"为已经获取到最短路径
                flag[k] = true;
    
                // 修正当前最短路径和前驱顶点
                // 即，当已经"顶点k的最短路径"之后，更新"未获取最短路径的顶点的最短路径和前驱顶点"。
                for (int j = 0; j < mVexs.length; j++) {
                    int tmp = getWeight(k, j);
                    tmp = (tmp==INF ? INF : (min + tmp)); // 防止溢出
                    if (flag[j]==false && (tmp<dist[j]) )
                    {
                        dist[j] = tmp;
                        prev[j] = k;
                    }
                }
            }
    
            // 打印dijkstra最短路径的结果
            System.out.printf("dijkstra(%c): \n", mVexs[vs].data);
            for (int i = 0; i < mVexs.length; i++)
                System.out.printf("  shortest(%c, %c)=%d\n", mVexs[vs].data, mVexs[i].data, dist[i]);
        }
    
    
        // 边的结构体
        private static class EData {
            char start; // 边的起点
            char end;   // 边的终点
            int weight; // 边的权重
    
            public EData(char start, char end, int weight) {
                this.start = start;
                this.end = end;
                this.weight = weight;
            }
        };
    
        public static void main(String[] args) {
            char[] vexs = {'A', 'B', 'C', 'D', 'E', 'F', 'G'};
            EData[] edges = {
                       // 起点 终点 权
                new EData('A', 'B', 12), 
                new EData('A', 'F', 16), 
                new EData('A', 'G', 14), 
                new EData('B', 'C', 10), 
                new EData('B', 'F',  7), 
                new EData('C', 'D',  3), 
                new EData('C', 'E',  5), 
                new EData('C', 'F',  6), 
                new EData('D', 'E',  4), 
                new EData('E', 'F',  2), 
                new EData('E', 'G',  8), 
                new EData('F', 'G',  9), 
            };
            ListUDG pG;
    
            // 自定义"图"(输入矩阵队列)
            //pG = new ListUDG();
            // 采用已有的"图"
            pG = new ListUDG(vexs, edges);
    
            //pG.print();   // 打印图
    
            int[] prev = new int[pG.mVexs.length];
            int[] dist = new int[pG.mVexs.length];
            // dijkstra算法获取"第4个顶点"到其它各个顶点的最短距离
            pG.dijkstra(3, prev, dist);
        }
    }

数据结构之查找

B-树

	B-树(即B树)是一种多路平衡查找树，B-树中所有结点 的孩子结点树的最大值称为B-树的阶，通常用m表示。一颗m阶的B-树，或为空树，或为满足下列特性的m叉树：

1. 树中每个结点至多有m棵子树(即至多有m-1个关键字)。
2. 若根节点不是叶结点，则至少有两棵子树。
3. 若除根结点外的所有非叶结点至少有[m/2]棵子树(即至少有[m/2]-1个关键字)。
4. 所有的非终端结点有以下数据：

   n  	P_0 	K_1 	P_1 	K_2 	P_2 	....	K_n 	P_n 
      	    	    	    	    	    	    	    	    

	其中，K_i(i=1,2,3..n)为结点的关键字，且有K_1<K_2<...<K_n;Pi(i=0,1,2...n)为指向子树根节点的指针，且指针P_i-1所指子树所有的结点的关键字均小于K_i，P_n所指子树中所有的结点的关键字均大于K_n，n([m/2]-1≤n≤m-1)为结点中关键字的个数。

    5.所有的叶结点都出现在同一层次上，并且不带信息(可以看作是外部结点或者类似于折半查找判定树中的失败结点，实际上这些点不存在，指向这些结点的指针为空)。

	B-树主要应用于文件系统，其大部分操作所需要的磁盘存取次数与B-树的高度成正比。B-树的高度与关键字个数的关系如下：

如n≥1，则对任意一棵包含n个关键字、高度为h、阶树为m的B-树：

1. 因为B-树中每个结点最多有m棵子树、m-1个关键字，所以在一棵高度为h的m阶B-树中关键字的个数满足n≤m^h-1，因此有h≥log_m(n+1)
2. 若让每个结点中的关键字个数达到最少，则容纳同样多关键字的B-树的高度可达到最大。由B-树定义：第一层至少有1个结点；第二层至少有2个结点除根节点以外的每个非终端结点至少有[m/2]棵子树，则第三层至少有2[m/2]个结点，第h+1层至少有2([m/2])^(h-1)个结点，注意到第h+1层是不包含任何信息的叶节点。对于关键字个数为n的B-树，叶结点即查找不成功的结点为n+1个，由此有n+1≥2([m/2])^(h-1)，即h≤log_[m/2][(n+1)/2]+1，例如，假设一棵3阶B-树，共有8个关键字，则其高度范围为2≤h≤3.17。

B+树

B+树是B-树的一种变形树，一棵m阶树应该满足下列条件：

1. 每个分支结点最多有m棵子树(子结点)。
2. 根结点或者没有子树，或者至少有两棵子树，其他的每个分支结点至少有[m/2]棵子树。
3. 结点的子树个数与关键字个数相等。
4. 所有叶结点包含全部关键字及其指向相应记录的指针，而且叶结点中将关键字按大小顺序排列，并且相邻叶结点顺序链接起来，所有叶结点在同一层。
5. 所有分支结点(可以看成是索引的索引)中仅包含其子树(即下一级的索引块)中关键字的最大值及其指向其子树的指针。

m阶B+树和m阶B-树的差异主要在于：

1. 在B+树中，具有n个关键字的结点只含有n棵子树，即每个关键字对应一棵子树；而在B-树中，具有n个关键字的结点含有(n+1)棵子树。
2. 在B+树中，每个非根结点关键字个数n的范围是[m/2]≤n≤m(根节点:1≤n≤m)；在B-树中，每个非根结点关键字个数n的范围是[m/2]-1≤n≤m-1(根节点:1≤n≤m-1)。
3. 在B+树中，所有非叶结点仅起到索引所用，即结点中的每个索引项只含有对应子树的最大关键字和指向该子树的指针，不含有该关键字对应记录的存储地址。
4. 在B+树中，叶结点包含了全部关键字，即其他非叶结点中的关键字包含在叶结点中；而在B-树中，叶结点包含的关键字和其他结点包含的关键字是不重复的。

数据结构之树

二叉树

二叉树的定义：二叉树的每个结点至多只有二棵子树(不存在度大于2的结点)，二叉树的子树有左右之分，次序不能颠倒。二叉树的第i层至多有2^{i-1}个结点；深度为k的二叉树至多有2^{k-1}个结点；对任何一棵二叉树T，如果其终端结点数为n_0，度为2的结点数为n_2，则n_0=n_2+1。

满二叉树和完全二叉树

　　满二叉树：除最后一层无任何子节点外，每一层上的所有结点都有两个子结点。也可以这样理解，除叶子结点外的所有结点均有两个子结点。节点数达到最大值，所有叶子结点必须在同一层上。

　　满二叉树的性质：

　　1) 一颗树深度为h，最大层数为k，深度与最大层数相同，k=h;

　　2) 叶子数为2^h;

　　3) 第k层的结点数是：2^{k-1};

　　4) 总结点数是：2^{k-1}，且总节点数一定是奇数。

　　完全二叉树：若设二叉树的深度为h，除第 h 层外，其它各层 (1～(h-1)层) 的结点数都达到最大个数，第h层所有的结点都连续集中在最左边，这就是完全二叉树。

　　注：完全二叉树是效率很高的数据结构，堆是一种完全二叉树或者近似完全二叉树，所以效率极高，像十分常用的排序算法、Dijkstra算法、Prim算法等都要用堆才能优化，二叉排序树的效率也要借助平衡性来提高，而平衡性基于完全二叉树。

二叉树的性质

1、在非空二叉树中，第i层的结点总数不超过2^{i-1}, i≥1;

2、深度为h的二叉树最多有2^{h-1}个结点(h≥1)，最少有h个结点;

3、对于任意一棵二叉树，如果其叶结点数为N_0，而度数为2的结点总数为N_2，则N_0=N_2+1;

4、具有n个结点的完全二叉树的深度为log_2(n+1);

5、有N个结点的完全二叉树各结点如果用顺序方式存储，则结点之间有如下关系：

　　若i为结点编号则 如果i>1，则其父结点的编号为i/2；

　　如果2i≤N，则其左儿子（即左子树的根结点）的编号为2i；若2i>N，则无左儿子；

　　如果2i+1≤N，则其右儿子的结点编号为2i+1；若2i+1>N，则无右儿子。

6、给定N个节点，能构成h(N)种不同的二叉树，其中h(N)为卡特兰数的第N项，h(n)=C(2*n, n)/(n+1)。

7、设有i个枝点，I为所有枝点的道路长度总和，J为叶的道路长度总和J=I+2i。

二叉树的遍历

二叉树的遍历是指按照某条搜索路径访问树中的每个节点，使得每个节点的均只被访问一次。由二叉树的递归定义，遍历一棵二叉树便要决定对根节点、左子树和右子树的访问顺序。常见的遍历次序有先序遍历、中序遍历和后序遍历。其中序指的是根节点在何时被访问。

1. 先序遍历(PreOrder)：若二叉树非空，则先访问根节点，再访问左子树，最后访问右子树。
2. 中序遍历(InOrder)：若二叉树非空，则先访问左子树，再访问根节点，最后访问右子树。
3. 后序遍历(PostOder)：若二叉树非空，则先访问左子树，再访问右子树，最后访问根节点。

节点结构如下：

    /**
     * 二叉树节点结构
     * Created by Administrator on 2017/5/2 0002.
     */
    public class TreeNode {
        public int val;
        public TreeNode left;
        public TreeNode right;
        public TreeNode(int x){
            this.val = x;
        }
    }

自定义节点处理函数：

    /*对每个节点进行处理*/
    public static void process(int v){
        System.out.println(v);
    }

先序遍历

    /*递归形式*/
    public static void preOrder(TreeNode root){
            if(root == null){
                return;
            }
            process(root.val);
            preOrder(root.left);
            preOrder(root.right);
        }

     //非递归形式，借助栈
        public static void preOrder2(TreeNode root) {
    
            if (root == null) {
                return;
            }
    
            Stack<TreeNode> stack = new Stack<>();
    
            while (root != null || !stack.isEmpty()) {
                while (root != null) {
                    print(root.val);
                    stack.push(root);
                    root = root.left;
                }
    
                if (!stack.isEmpty()) {
                    root = stack.peek();
                    stack.pop();
                    root = root.right;
                }
            }
        }

中序遍历

    /*递归形式*/
    public static void inOrder(TreeNode root){
        if(root == null){
            return;
        }
        if(root.left != null){
            inOrder(root.left);
        }
        process(root.val);
        if(root.right != null){
            inOrder(root.right);
        }	
    }

    /*非递归形式*/
    public static void inOrder(TreeNode root){
        if(root == null){
            return;
        }
        Stack<TreeNode> st = new Stack<TreeNode>();
        st.push(root);
        TreeNode tmp;
        while (!st.empty()){
            tmp = st.peek();
            while (tmp != null){
                st.push(tmp.left);
                tmp = tmp.left;
            }
            if(tmp == null){
                st.pop();
            }
            if(!st.empty()) {
                tmp = st.pop();
                process(tmp.val);
                st.push(tmp.right);
            }
        }
    }

后序遍历

    /*递归形式*/
    public static void postOrder(TreeNode root){
        if(root == null){
            return;
        }
        if(root.left != null){
            postOrder(root.left);
        }
        if(root.right != null){
            postOrder(root.right);
        }
        process(root.val);
    }

    /*后序非递归形式*/
    public static void postOrder(TreeNode root){
       if (root == null) {
                return;
            }
    
            Stack<TreeNode> stack = new Stack<>();
            TreeNode node = root;
            //最后访问的节点
            TreeNode lastVisit = root;
            while (node != null || !stack.isEmpty()) {
    
                //左子树入栈
                while (node != null) {
                    stack.push(node);
                    node = node.left;
                }
    
                //查看当前栈顶元素
                node = stack.peek();
    
                //如果其右子树也为空，或者右子树已经访问
                //则可以直接输出当前节点的值
                if (node.right == null || node.right == lastVisit) {
                    print(node.val);
                    stack.pop();
                    lastVisit = node;
                    node = null;
                } else {
                    //否则遍历右子树
                    node = node.right;
                }
            }
    }
